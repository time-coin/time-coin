// Add this after the MempoolEntry struct definition (around line 22)
// Make MempoolEntry serializable
use serde::{Serialize, Deserialize};

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct MempoolEntry {
    pub transaction: Transaction,
    pub added_at: i64,
    pub priority: u64,
}

// Add these methods to the impl Mempool block (before the closing brace)
    /// Save mempool to disk
    pub async fn save_to_disk(&self, path: &str) -> Result<(), Box<dyn std::error::Error>> {
        let pool = self.transactions.read().await;
        let entries: Vec<&MempoolEntry> = pool.values().collect();
        
        // Create directory if it doesn't exist
        if let Some(parent) = std::path::Path::new(path).parent() {
            std::fs::create_dir_all(parent)?;
        }
        
        let json = serde_json::to_string_pretty(&entries)?;
        std::fs::write(path, json)?;
        
        Ok(())
    }

    /// Load mempool from disk
    pub async fn load_from_disk(&self, path: &str) -> Result<usize, Box<dyn std::error::Error>> {
        if !std::path::Path::new(path).exists() {
            return Ok(0);
        }
        
        let json = std::fs::read_to_string(path)?;
        let entries: Vec<MempoolEntry> = serde_json::from_str(&json)?;
        
        let mut pool = self.transactions.write().await;
        let mut loaded = 0;
        let now = chrono::Utc::now().timestamp();
        
        for entry in entries {
            // Skip transactions older than 24 hours
            if now - entry.added_at > 86400 {
                continue;
            }
            
            // Skip if mempool is full
            if pool.len() >= self.max_size {
                break;
            }
            
            pool.insert(entry.transaction.txid.clone(), entry);
            loaded += 1;
        }
        
        Ok(loaded)
    }

    /// Clean up stale transactions (older than 24 hours)
    pub async fn cleanup_stale(&self) -> usize {
        let mut pool = self.transactions.write().await;
        let now = chrono::Utc::now().timestamp();
        let mut removed = 0;
        
        pool.retain(|_, entry| {
            let is_fresh = now - entry.added_at < 86400;
            if !is_fresh {
                removed += 1;
            }
            is_fresh
        });
        
        removed
    }

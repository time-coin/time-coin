
async fn receive_block_proposal(
    State(state): State<ApiState>,
    Json(proposal): Json<serde_json::Value>,
) -> ApiResult<Json<serde_json::Value>> {
    use time_consensus::block_consensus::BlockProposal;
    
    // Parse the proposal
    let block_proposal: BlockProposal = serde_json::from_value(proposal)
        .map_err(|e| ApiError::Internal(format!("Invalid proposal format: {}", e)))?;
    
    println!("üì¶ Received block proposal for height {}", block_proposal.block_height);
    println!("   Proposer: {}", block_proposal.proposer);
    println!("   Block hash: {}...", &block_proposal.block_hash[..16]);
    
    // Store proposal in block_consensus
    if let Some(block_consensus) = state.block_consensus.as_ref() {
        block_consensus.propose_block(block_proposal.clone()).await;
        
        // Auto-vote if we're a validator (not the proposer)
        let blockchain = state.blockchain.read().await;
        let my_id = "self"; // TODO: Get from config
        
        if my_id != block_proposal.proposer {
            // Automatically vote approve
            use time_consensus::block_consensus::BlockVote;
            let vote = BlockVote {
                block_height: block_proposal.block_height,
                block_hash: block_proposal.block_hash.clone(),
                voter: my_id.to_string(),
                approve: true,
                timestamp: chrono::Utc::now().timestamp(),
            };
            
            let _ = block_consensus.vote_on_block(vote).await;
        }
    }
    
    Ok(Json(json!({
        "success": true,
        "message": "Block proposal received and processed"
    })))
}

async fn receive_block_vote(
    State(state): State<ApiState>,
    Json(vote): Json<serde_json::Value>,
) -> ApiResult<Json<serde_json::Value>> {
    use time_consensus::block_consensus::BlockVote;
    
    // Parse the vote
    let block_vote: BlockVote = serde_json::from_value(vote)
        .map_err(|e| ApiError::Internal(format!("Invalid vote format: {}", e)))?;
    
    let vote_type = if block_vote.approve { "APPROVE ‚úì" } else { "REJECT ‚úó" };
    println!("üó≥Ô∏è  Received block vote: {} from {}", vote_type, block_vote.voter);
    
    // Store vote in block_consensus
    if let Some(block_consensus) = state.block_consensus.as_ref() {
        block_consensus.vote_on_block(block_vote.clone()).await
            .map_err(|e| ApiError::Internal(e))?;
        
        // Check if we now have consensus
        let (has_consensus, approvals, total) = block_consensus
            .has_block_consensus(block_vote.block_height, &block_vote.block_hash).await;
        
        if has_consensus {
            println!("   ‚úÖ CONSENSUS REACHED for block {} ({}/{} votes)", 
                block_vote.block_height, approvals, total);
        } else {
            println!("   ‚è≥ Waiting for consensus: {}/{} votes", approvals, total);
        }
    }
    
    Ok(Json(json!({
        "success": true,
        "approved": block_vote.approve
    })))
}

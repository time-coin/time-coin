async fn receive_block_proposal(
    State(state): State<ApiState>,
    Json(proposal): Json<serde_json::Value>,
) -> ApiResult<Json<serde_json::Value>> {
    use time_consensus::block_consensus::BlockProposal;
    
    let block_proposal: BlockProposal = serde_json::from_value(proposal)
        .map_err(|e| ApiError::Internal(format!("Invalid proposal format: {}", e)))?;
    
    println!("üì¶ Received block proposal for height {}", block_proposal.block_height);
    println!("   Proposer: {}", block_proposal.proposer);
    println!("   Block hash: {}...", &block_proposal.block_hash[..16]);
    
    if let Some(block_consensus) = state.block_consensus.as_ref() {
        block_consensus.propose_block(block_proposal.clone()).await;
    }
    
    Ok(Json(json!({
        "success": true,
        "message": "Block proposal received"
    })))
}

async fn receive_block_vote(
    State(state): State<ApiState>,
    Json(vote): Json<serde_json::Value>,
) -> ApiResult<Json<serde_json::Value>> {
    use time_consensus::block_consensus::BlockVote;
    
    let block_vote: BlockVote = serde_json::from_value(vote)
        .map_err(|e| ApiError::Internal(format!("Invalid vote format: {}", e)))?;
    
    let vote_type = if block_vote.approve { "APPROVE ‚úì" } else { "REJECT ‚úó" };
    println!("üó≥Ô∏è  Received block vote: {} from {}", vote_type, block_vote.voter);
    
    if let Some(block_consensus) = state.block_consensus.as_ref() {
        block_consensus.vote_on_block(block_vote.clone()).await
            .map_err(|e| ApiError::Internal(e))?;
        
        let (has_consensus, approvals, total) = block_consensus
            .has_block_consensus(block_vote.block_height, &block_vote.block_hash).await;
        
        if has_consensus {
            println!("   ‚úÖ CONSENSUS REACHED ({}/{})", approvals, total);
        } else {
            println!("   ‚è≥ Waiting... ({}/{})", approvals, total);
        }
    }
    
    Ok(Json(json!({
        "success": true
    })))
}
